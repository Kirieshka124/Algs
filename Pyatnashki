import random
import time

SIZE = 4
BLANK = 0
UP = 'up'
DOWN = 'down'
LEFT = 'left'
RIGHT = 'right'


def displayBoard(board):
    """Отображает текущее состояние доски"""
    for y in range(SIZE):
        for x in range(SIZE):
            if board[y * SIZE + x] == BLANK:
                print('__ ', end='')
            else:
                print(str(board[y * SIZE + x]).rjust(2) + ' ', end='')
        print()


def getNewBoard():
    """Создает решенную доску"""
    return [i for i in range(1, SIZE * SIZE)] + [BLANK]


def inputBoard():
    """Позволяет пользователю ввести доску вручную"""
    print("Введите числа для каждой строки доски (используйте 0 для пустой клетки):")
    board = []
    for y in range(SIZE):
        while True:
            row_input = input(f"Строка {y + 1} (4 числа через пробел): ").strip().split()
            if len(row_input) != SIZE:
                print(f"Нужно ввести ровно {SIZE} числа!")
                continue

            try:
                row = [int(num) for num in row_input]
                board.extend(row)
                break
            except ValueError:
                print("Пожалуйста, вводите только числа!")

    # Проверка корректности введенной доски
    expected_numbers = set(range(SIZE * SIZE))
    if set(board) != expected_numbers:
        print(f"Ошибка: в доске должны быть все числа от 0 до {(SIZE*SIZE)-1}!")
        return inputBoard()  # Рекурсивно запрашиваем снова

    return board


def findBlankSpace(board):
    """Находит координаты пустой клетки"""
    index = board.index(BLANK)
    return (index % SIZE, index // SIZE)


def makeMove(board, move):
    """Выполняет ход в указанном направлении"""
    bx, by = findBlankSpace(board)
    blankIndex = by * SIZE + bx

    if move == UP:
        if by == SIZE - 1: return False
        tileIndex = (by + 1) * SIZE + bx
    elif move == LEFT:
        if bx == SIZE - 1: return False
        tileIndex = by * SIZE + (bx + 1)
    elif move == DOWN:
        if by == 0: return False
        tileIndex = (by - 1) * SIZE + bx
    elif move == RIGHT:
        if bx == 0: return False
        tileIndex = by * SIZE + (bx - 1)
    else:
        return False

    board[blankIndex], board[tileIndex] = board[tileIndex], board[blankIndex]
    return True


def getValidMoves(board, prevMove=None):
    """Возвращает список допустимых ходов"""
    blankx, blanky = findBlankSpace(board)
    validMoves = []

    if blanky != SIZE - 1 and prevMove != DOWN:
        validMoves.append(UP)
    if blankx != SIZE - 1 and prevMove != RIGHT:
        validMoves.append(LEFT)
    if blanky != 0 and prevMove != UP:
        validMoves.append(DOWN)
    if blankx != 0 and prevMove != LEFT:
        validMoves.append(RIGHT)

    return validMoves


def solve(board, maxDepth):
    """Решает головоломку с ограничением глубины поиска"""
    solutionMoves = []

    def dfs(currentBoard, depth, prevMove, path):
        nonlocal solutionMoves
        if depth > maxDepth:
            return False
        if currentBoard == SOLVED_BOARD:
            solutionMoves = path.copy()
            return True

        for move in getValidMoves(currentBoard, prevMove):
            newBoard = currentBoard.copy()
            makeMove(newBoard, move)
            if dfs(newBoard, depth + 1, move, path + [move]):
                return True
        return False

    if dfs(board.copy(), 0, None, []):
        print("\nРешение найдено!")
        displayBoard(board)
        current_board = board.copy()
        for move in solutionMoves:
            print(f"\nХод: {move}")
            makeMove(current_board, move)
            displayBoard(current_board)

        print(f"\nВсего ходов: {len(solutionMoves)}")
        print("Последовательность ходов:", ', '.join(solutionMoves))
        return True

    return False


# Основная программа
SOLVED_BOARD = getNewBoard()

print("15-головоломка (Пятнашки)")
print("1. Случайная головоломка")
print("2. Ввести головоломку вручную")
choice = input("Выберите вариант (1/2): ")

if choice == '1':
    DIFFICULTY = 40
    puzzleBoard = getNewBoard()
    for i in range(DIFFICULTY):
        validMoves = getValidMoves(puzzleBoard)
        makeMove(puzzleBoard, random.choice(validMoves))
    print("\nСлучайная головоломка:")
    displayBoard(puzzleBoard)
elif choice == '2':
    puzzleBoard = inputBoard()
    print("\nВаша головоломка:")
    displayBoard(puzzleBoard)
else:
    print("Неверный выбор. Используется случайная головоломка.")
    puzzleBoard = getNewBoard()

startTime = time.time()
maxMoves = 10

print("\nНачинаем решение...")
while True:
    if solve(puzzleBoard, maxMoves):
        break
    maxMoves += 1
    print(f"Увеличиваем глубину поиска до {maxMoves} ходов...")

print(f"\nВремя выполнения: {round(time.time() - startTime, 3)} секунд")
